import java.util.ArrayList;


public class solution {

	/*	Binary Tree Node class
	 * 
	 * class BinaryTreeNode<T> {
		T data;
		BinaryTreeNode<T> left;
		BinaryTreeNode<T> right;

		public BinaryTreeNode(T data) {
			this.data = data;
		}
	}
	 */

	public static boolean isCousin(BinaryTreeNode<Integer> root, int a, int b) {
		// Write your code here
        if ((level(root,a,1) == level(root,b,1)) && !(isSibling(root,a,b))) 
        return true; 
    else return false;
    }
    
    public static int level(BinaryTreeNode<Integer> root, int ptr, int lev) 
{ 
    // base cases 
    if (root == null) return 0; 
    if (root.data == ptr)  return lev; 
  
    // Return level if Node is present in left subtree 
    int l = level(root.left, ptr, lev+1); 
    if (l != 0)  return l; 
  
    // Else search in right subtree 
    return level(root.right, ptr, lev+1); 
} 
    
    public static boolean isSibling(BinaryTreeNode<Integer> root, int data_one, 
                             int data_two) 
{ 
        
    if (root!=null) 
        return false; 
  
    // Compare the two given nodes with 
    // the childrens of current node 
    if (root.left!=null && root.right!=null) { 
        int left = root.left.data; 
        int right = root.right.data; 
  
        if (left == data_one && right == data_two) 
            return true; 
        else if (left == data_two && right == data_one) 
            return true; 
    } 
  
    // Check for left subtree 
    if (root.left!=null) 
         isSibling(root.left, data_one, 
                                data_two); 
  
    // Check for right subtree 
    if (root.right!=null) 
         isSibling(root.right, data_one, 
                                data_two); 
        return true;      
}      
}
